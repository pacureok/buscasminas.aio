<video>
  <h1>Buscaminas Aio</h1>
  <div class="header">
    <button id="reset-button">Reiniciar</button>
    <div id="status-message"></div>
  </div>
  <div id="tablero"></div>
</video>
<np>

<cs>
body {
  font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
  text-align: center;
  background-color: #2c3e50;
  color: #ecf0f1;
  margin: 20px; /* Margen para evitar que el contenido se pegue a los bordes */
}
.header {
  margin-bottom: 20px;
}
#tablero {
  display: grid;
  grid-template-columns: repeat(10, 35px);
  grid-template-rows: repeat(10, 35px);
  width: fit-content;
  margin: auto;
  border: 4px solid #34495e;
  border-right-color: #7f8c8d;
  border-bottom-color: #7f8c8d;
}
.celda {
  width: 35px;
  height: 35px;
  border: 2px solid;
  border-color: #7f8c8d #bdc3c7 #bdc3c7 #7f8c8d;
  background-color: #95a5a6;
  font-size: 20px;
  font-weight: bold;
  line-height: 30px;
  text-align: center;
  cursor: pointer;
}
.celda.revelada {
  border-color: #34495e;
  background-color: #bdc3c7;
  cursor: default;
}
.celda.revelada.bomba {
  background-color: #e74c3c;
  color: white;
}
.celda.flagged {
  background-image: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="35" height="35"><text x="50%" y="50%" dominant-baseline="middle" text-anchor="middle" font-size="24" fill="red">üö©</text></svg>');
  background-size: cover;
  background-color: #f1c40f; /* Color de fondo para que la bandera resalte */
}
/* Estilos para los n√∫meros de bombas alrededor */
.numero-1 { color: blue; }
.numero-2 { color: green; }
.numero-3 { color: red; }
.numero-4 { color: purple; }
.numero-5 { color: maroon; }
.numero-6 { color: teal; }
.numero-7 { color: black; }
.numero-8 { color: gray; }

#reset-button {
  padding: 10px 20px;
  font-size: 16px;
  cursor: pointer;
  background-color: #2ecc71;
  color: white;
  border: none;
  border-radius: 5px;
  transition: background-color 0.3s ease;
}
#reset-button:hover {
  background-color: #27ae60;
}
#status-message {
  font-size: 24px;
  margin-top: 15px;
  min-height: 30px; /* Para mantener el espacio incluso si est√° vac√≠o */
}
</cs>
<np>

<tp>
const tablero = document.getElementById('tablero');
const resetButton = document.getElementById('reset-button');
const statusMessage = document.getElementById('status-message');
const ancho = 10;
const numeroBombas = 15;
let celdas = [];
let gameOver = false;
let banderasRestantes = numeroBombas; // Control de banderas

function crearTablero() {
  gameOver = false;
  statusMessage.textContent = '';
  statusMessage.style.color = 'white'; // Reiniciar color
  tablero.innerHTML = '';
  celdas = [];
  banderasRestantes = numeroBombas;

  const arrayBombas = Array(numeroBombas).fill('bomba');
  const arrayVacio = Array(ancho * ancho - numeroBombas).fill('valido');
  const arrayJuego = arrayVacio.concat(arrayBombas).sort(() => Math.random() - 0.5);

  for (let i = 0; i < ancho * ancho; i++) {
    const celda = document.createElement('div');
    celda.classList.add('celda');
    celda.setAttribute('id', i);
    celda.dataset.tipo = arrayJuego[i];
    tablero.appendChild(celda);
    celdas.push(celda);
  }
  
  // Asignar los n√∫meros a las celdas
  for (let i = 0; i < celdas.length; i++) {
    let cuentaBombas = 0;
    const isLeftEdge = (i % ancho === 0);
    const isRightEdge = (i % ancho === ancho - 1);

    if (celdas[i].dataset.tipo === 'valido') {
      // Check neighbors for bombs
      // Top-left
      if (i > 0 && !isLeftEdge && celdas[i-1].dataset.tipo === 'bomba') cuentaBombas++;
      // Top-right
      if (i < 99 && !isRightEdge && celdas[i+1].dataset.tipo === 'bomba') cuentaBombas++;
      // Top (directly above)
      if (i >= ancho && celdas[i-ancho].dataset.tipo === 'bomba') cuentaBombas++;
      // Bottom (directly below)
      if (i < (ancho * ancho - ancho) && celdas[i+ancho].dataset.tipo === 'bomba') cuentaBombas++;
      // Diagonal top-left
      if (i > ancho && !isLeftEdge && celdas[i-ancho-1].dataset.tipo === 'bomba') cuentaBombas++;
      // Diagonal top-right
      if (i > (ancho -1) && !isRightEdge && celdas[i-ancho+1].dataset.tipo === 'bomba') cuentaBombas++;
      // Diagonal bottom-left
      if (i < (ancho * ancho - ancho) && !isLeftEdge && celdas[i+ancho-1].dataset.tipo === 'bomba') cuentaBombas++;
      // Diagonal bottom-right
      if (i <= (ancho * ancho - ancho - 2) && !isRightEdge && celdas[i+ancho+1].dataset.tipo === 'bomba') cuentaBombas++;

      if (cuentaBombas > 0) {
        celdas[i].textContent = cuentaBombas;
        celdas[i].classList.add(`numero-${cuentaBombas}`);
      }
    }
  }

  // Event listeners para las celdas
  celdas.forEach(celda => {
    celda.addEventListener('click', () => {
      revelarCelda(celda);
    });
    celda.addEventListener('contextmenu', (e) => {
      e.preventDefault(); // Prevenir el men√∫ contextual predeterminado
      marcarCelda(celda);
    });
  });
}

function revelarCelda(celda) {
  if (gameOver || celda.classList.contains('revelada') || celda.classList.contains('flagged')) return;
  
  if (celda.dataset.tipo === 'bomba') {
    mostrarBombas();
    statusMessage.textContent = '¬°Game Over! ‚ùåüö´';
    statusMessage.style.color = '#e74c3c'; // Rojo para Game Over
    gameOver = true;
    return;
  }
  
  celda.classList.add('revelada');
  if (celda.textContent === '') {
    // Revelar celdas adyacentes si est√° vac√≠a
    const id = parseInt(celda.id);
    // Usamos setTimeout para evitar un stack overflow en tableros grandes
    // y para dar un peque√±o efecto de animaci√≥n en cascada.
    setTimeout(() => {
      revelarAdyacentes(id);
    }, 10);
  }
  verificarVictoria();
}

function revelarAdyacentes(id) {
  const isLeftEdge = (id % ancho === 0);
  const isRightEdge = (id % ancho === ancho - 1);
  const vecinos = [
    id - 1,       // izquierda
    id + 1,       // derecha
    id - ancho,   // arriba
    id + ancho,   // abajo
    id - ancho - 1, // diagonal superior izquierda
    id - ancho + 1, // diagonal superior derecha
    id + ancho - 1, // diagonal inferior izquierda
    id + ancho + 1  // diagonal inferior derecha
  ];

  vecinos.forEach(vecinoId => {
    if (vecinoId >= 0 && vecinoId < (ancho * ancho)) { // Asegurarse de que el ID est√© dentro del rango
      // Evitar que las celdas de un borde revelen las del otro lado
      if ((isLeftEdge && [id - 1, id - ancho - 1, id + ancho - 1].includes(vecinoId)) ||
          (isRightEdge && [id + 1, id - ancho + 1, id + ancho + 1].includes(vecinoId))) {
        return;
      }
      const vecinoCelda = celdas[vecinoId];
      if (!vecinoCelda.classList.contains('revelada') && !vecinoCelda.classList.contains('flagged')) {
        revelarCelda(vecinoCelda);
      }
    }
  });
}

function marcarCelda(celda) {
  if (gameOver) return; // No se puede marcar si el juego ha terminado
  if (celda.classList.contains('revelada')) return; // No se puede marcar una celda ya revelada

  if (!celda.classList.contains('flagged') && banderasRestantes > 0) {
    celda.classList.add('flagged');
    banderasRestantes--;
  } else if (celda.classList.contains('flagged')) {
    celda.classList.remove('flagged');
    banderasRestantes++;
  }
  // Podr√≠amos mostrar el n√∫mero de banderas restantes aqu√≠
}

function mostrarBombas() {
  celdas.forEach(celda => {
    if (celda.dataset.tipo === 'bomba') {
      celda.classList.add('revelada', 'bomba');
      // Opcional: mostrar una imagen de bomba
    }
  });
}

function verificarVictoria() {
  // Una forma de ganar: todas las celdas no-bomba han sido reveladas
  const celdasNoBombas = celdas.filter(celda => celda.dataset.tipo === 'valido');
  const celdasReveladasNoBombas = celdasNoBombas.filter(celda => celda.classList.contains('revelada'));

  if (celdasReveladasNoBombas.length === celdasNoBombas.length) {
    statusMessage.textContent = '¬°Victoria! üéâ';
    statusMessage.style.color = '#2ecc71'; // Verde para victoria
    gameOver = true;
    mostrarBombas(); // Opcional: mostrar bombas al ganar
  }
}

resetButton.addEventListener('click', crearTablero);
crearTablero(); // Inicializar el tablero al cargar la p√°gina
</tp>
<np>

(esp)
# L√≥gica principal del juego para el motor (esp).
# Este bloque demuestra c√≥mo la l√≥gica del juego podr√≠a ser abstracta aqu√≠.

# Variables de configuraci√≥n del juego (aunque el JS ya las usa)
# Podr√≠amos pasar estas a JS si tuvi√©ramos un motor (esp) completo
$creafuntion "configurar_juego" &intert 
(
  tablero_ancho = 10,
  tablero_alto = 10,
  num_bombas = 15
),

# Regla para verificar el estado de victoria/derrota del juego
$inter=rule(berific_estado_juego (pin= "victoria" "derrota" "jugando")),

@decte (pin= "victoria" of accion "estado_juego"=run mostrar_mensaje_victoria {</video> mensaje_victoria "¬°Has ganado!"}),
@decte (pin= "derrota" of accion "estado_juego"=run mostrar_mensaje_derrota {</video> mensaje_derrota "¬°Boom! Perdiste."}),
@decte (pin= "jugando" of accion "estado_juego"=run actualizar_estado_ui {</video> actualiza_ui_juego}),

# Asignar tecla 'R' (Reset) para reiniciar el juego
# Aqu√≠ conceptualizamos que una tecla externa (R) disparar√≠a la funci√≥n JS de reset.
$creafuntion "reset_juego_externo" &intert (<tp>resetButton.click();</tp>),
@decte (evento_tecla= [R] of accion "reset_juego_externo"=run "reset_juego_externo" {</video>}),

# Ejemplo de una funci√≥n que podr√≠a ser llamada por JS para obtener un valor
$creafuntion "obtener_numero_bombas" &intert 
(
  # En un motor (esp) real, esto devolver√≠a la variable 'num_bombas' definida arriba.
  # Para esta demo, conceptualizamos que JS la leer√≠a.
  retorno = 15 
),
(/esp)
<np>

<ING>
# Main game logic for the (ING) engine.
# This block shows parallel syntax for English commands.

# Game configuration variables
$create_function "configure_game" &insert 
(
  board_width = 10,
  board_height = 10,
  num_mines = 15
),

# Rule to verify game state (win/lose/playing)
$inter=rule(verify_game_state (pin= "win" "lose" "playing")),

@detect (pin= "win" of action "game_state"=run show_win_message {</video> win_message "You won!"}),
@detect (pin= "lose" of action "game_state"=run show_lose_message {</video> lose_message "Boom! You lost."}),
@detect (pin= "playing" of action "game_state"=run update_game_ui {</video> update_ui_game}),

# Assign 'R' key for game reset
$create_function "external_game_reset" &insert (<tp>resetButton.click();</tp>),
@detect (key_event= [R] of action "external_game_reset"=run "external_game_reset" {</video>}),

# Example function to get a value
$create_function "get_number_of_mines" &insert (return_value = 15),
</ING>
<np>

<net>
// C√≥digo C# para .NET.
// Este bloque demuestra c√≥mo se podr√≠a incluir c√≥digo C# en .Aio.
// Por ejemplo, para una l√≥gica de backend o una API REST para el juego.

using System;
using System.Collections.Generic;

namespace MinesweeperAioBackend
{
    public class GameState
    {
        public int BoardWidth { get; set; } = 10;
        public int BoardHeight { get; set; } = 10;
        public int NumberOfMines { get; set; } = 15;
        public List<Tuple<int, int>> MineLocations { get; set; }

        public GameState()
        {
            MineLocations = new List<Tuple<int, int>>();
            PlaceMines();
        }

        private void PlaceMines()
        {
            Random rand = new Random();
            while (MineLocations.Count < NumberOfMines)
            {
                int x = rand.Next(0, BoardWidth);
                int y = rand.Next(0, BoardHeight);
                Tuple<int, int> newMine = new Tuple<int, int>(x, y);

                if (!MineLocations.Contains(newMine))
                {
                    MineLocations.Add(newMine);
                }
            }
            Console.WriteLine($"Backend .NET: {MineLocations.Count} minas colocadas.");
        }

        // M√©todo de ejemplo que podr√≠a ser llamado por un frontend
        public string GetMineLocationsJson()
        {
            // En un caso real, esto ser√≠a JSON serializado
            return $"Minas: {string.Join(", ", MineLocations)}";
        }
    }

    public class Program
    {
        public static void Main(string[] args)
        {
            Console.WriteLine("Iniciando componente .NET del Buscaminas Aio.");
            GameState game = new GameState();
            Console.WriteLine(game.GetMineLocationsJson());
        }
    }
}
</net>
<np>

<lua>
-- C√≥digo Lua para scripts ligeros.
-- Podr√≠a usarse para definir configuraciones de dificultad o IA de bots.

local config = {
    difficulty = "normal",
    board_size = {width = 10, height = 10},
    mine_percentage = 0.15
}

function get_difficulty_mines(size, percentage)
    return math.floor(size.width * size.height * percentage)
end

local mines_for_current_difficulty = get_difficulty_mines(config.board_size, config.mine_percentage)

print("Componente Lua del Buscaminas Aio iniciado.")
print("Dificultad seleccionada: " .. config.difficulty)
print("N√∫mero de minas calculado por Lua: " .. mines_for_current_difficulty)

-- Funci√≥n de ejemplo que podr√≠a ser llamada desde el motor principal para obtener una configuraci√≥n
function get_game_config()
    return config
end
</lua>
